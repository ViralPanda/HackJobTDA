import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Set;

/**
 * Program to read in a text file and report word/phrase frequency.
 *
 * @author Charlette Lin, Katie Dragga, Viral Patel
 * @version 20151113
 */
public final class CountPhrases2 {

    private static final int MIN_FONT_SIZE = 11;
    private static final int MAX_FONT_SIZE = 48;

    private static int minCount = 0;
    private static int maxCount = 0;

    public static class EntryComp implements
            Comparator<Map.Entry<String, Integer>> {

        @Override
        public int compare(Entry<String, Integer> entryOne,
                Entry<String, Integer> entryTwo) {
            return entryTwo.getValue().compareTo(entryOne.getValue());
        }
    }

    public static class EntryCompKeys implements
            Comparator<Map.Entry<String, Integer>> {

        @Override
        public int compare(Entry<String, Integer> entryOne,
                Entry<String, Integer> entryTwo) {
            return entryOne.getKey().compareTo(entryTwo.getKey());
        }
    }

    /**
     * Method to add a single phrase as a key to the map (with initial value 1),
     * or increment its count if it already exists as a key.
     *
     */
    public static void addToFrequencyMap(String phrase,
            Map<String, Integer> frequency) {
        if (frequency.keySet().contains(phrase)) {
            // pull out the current value for the current key (s)
            int count = frequency.get(phrase);
            count++;
            frequency.put(phrase, count);
        } else {
            frequency.put(phrase, 1);
        }
    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <pre>
     * <html>
     * <head>
     * <title></title>
     * </head>
     * <body> (and also the green header text and two rule lines)
     * </pre>
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     * @throws IOException
     *             if there are problems writing to the output file
     */
    private static void outputHeader(PrintWriter out) throws IOException {
        out.println("<html>");
        out.println("<head>");
        out.println("<title>");
        out.println("Student Employment Data Analysis");
        out.println("</title>");
        out.println("</head>");
        out.println("<body background=\"background.png\">");
        out.println("<link href=\"tagcloud.css\" rel=\"stylesheet\" type"
                + "=\"text/css\">");
        out.println("<h1><strong><font color=\"black\"> "
                + "Employment Data Analysis</strong></br></font></h1><h2><font color=\"black\"><em>Matching Student Resumes </br>with Job Postings</em>"
                + " </font></h2>");
        out.println("<hr />");
        out.println("<hr />");
    }

    /**
     * Outputs a tag cloud of words to the html page.
     *
     * @param out
     *            the output stream
     * @param wordAndCount
     *            a Map<String, Integer> containing all words/phrases included,
     *            paired with their counts
     * @param header
     *            the String used as a column header
     * @clears wordAndCount
     * @updates out.contents
     * @requires wordAndCount is not null
     * @ensures out.content = #out.content * [a table listing words in
     *          appropriate sizes]
     * @throws IOException
     *             if there are problems writing to the output file
     */
    private static void printCloud(PrintWriter out,
            Map<String, Integer> wordAndCount, String header)
                    throws IOException {

        Comparator<Map.Entry<String, Integer>> compareKeys = new EntryCompKeys();

        // Remove all of the Map.Entry pairs from wordAndCount and place
        // them in orderedCountQueue. (They will be placed into the queue in
        // descending value order.)

        PriorityQueue<Map.Entry<String, Integer>> orderedCountQueue = new PriorityQueue<Map.Entry<String, Integer>>(
                wordAndCount.size(), compareKeys);
        for (Map.Entry<String, Integer> pair : wordAndCount.entrySet()) {
            orderedCountQueue.add(pair);
        }

        // record minimum and maximum counts of words that will be included in cloud
        int minCount = orderedCountQueue.peek().getValue();
        int maxCount = orderedCountQueue.peek().getValue();

        // find the min and max values to be included, transferring values to another queue
        PriorityQueue<Map.Entry<String, Integer>> holdingQueue = new PriorityQueue<Map.Entry<String, Integer>>(
                wordAndCount.size(), compareKeys);

        while (orderedCountQueue.size() > 0) {
            Map.Entry<String, Integer> wordPair = orderedCountQueue.poll();
            if (wordPair.getValue() > maxCount) {
                maxCount = wordPair.getValue();
            } else if (wordPair.getValue() < minCount) {
                minCount = wordPair.getValue();
            }
            holdingQueue.add(wordPair);
        }
        out.println(header);

        CountPhrases2.maxCount = maxCount;
        CountPhrases2.minCount = minCount;

        while (holdingQueue.size() > 0) {
            Map.Entry<String, Integer> pairToPrint = holdingQueue.poll();
            String word = pairToPrint.getKey();
            Integer count = pairToPrint.getValue();
            int fontSize = (MAX_FONT_SIZE + MIN_FONT_SIZE) / 2;
            if (minCount != maxCount) {
                fontSize = (((MAX_FONT_SIZE - MIN_FONT_SIZE) * (count - minCount)) / (maxCount - minCount))
                        + MIN_FONT_SIZE;
            }
            out.println("<span style=\"cursor:default\" class=\"f" + fontSize
                    + "\" title=\"count: " + count + "\">" + word + "</span>");
        }
    }

    /**
     * Outputs the "closing" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * </p> </body> </html>
     *
     * @param out
     *            the output stream
     * @updates out.contents
     * @ensures out.content = #out.content * [the HTML "closing" tags]
     * @throws IOException
     *             if there are problems writing to the output file
     */
    private static void outputFooter(PrintWriter out) throws IOException {
        out.println("</p>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments; unused here
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        Scanner keyboard = new Scanner(System.in);
        System.out
                .println("Please enter the name of a file containing employer job descriptions: ");
        String fileName = keyboard.nextLine();
        Map<String, Integer> phrases1 = createFileAndDoStuff(fileName);

        System.out
        .println("Please enter the name of a file containing student resume descriptions: ");
        fileName = keyboard.nextLine();
        Map<String, Integer> phrases2 = createFileAndDoStuff(fileName);

        printStuff(phrases1, phrases2);

        keyboard.close();

    }

    public static void printStuff(Map<String, Integer> phrases1,
            Map<String, Integer> phrases2) throws IOException {
        PrintWriter index = null;
        PrintWriter student = null;
        PrintWriter recommend = null;
        try {
            index = new PrintWriter(new BufferedWriter(new FileWriter(
                    "data/jobAndResumeData.html")));
            outputHeader(index);
            printCloud(index, phrases1,
                    "<h2><strong>Employers seek:</strong></h3>");
            // index.println("<br><br><br><a href=\"studentPage.html\">Click here for the students' most frequently-used keywords.</a>");
            // index.println("<br><a href=\"recommendationPage.html\">Click here to see recommendations for employers and students.</a>");

            //student = new PrintWriter(new BufferedWriter(new FileWriter(
            //        "data/studentPage.html")));
            //outputHeader(student);
            printCloud(index, phrases2,
                    "<h2><strong><br>Students offer:</strong></h3>");
            index.println("<br><br><h2><strong><br>Similarities in postings and resumes:</strong></h2>");
            Set<String> intersection = intersection(phrases1, phrases2);
            printTable(phrases1, phrases2, intersection, index);

            Set<String> diff = difference(phrases1, phrases2);
            Map<String, Integer> mapCpy = new HashMap<>(phrases1);
            mapCpy.keySet().retainAll(diff);
            printCloud(index, mapCpy,
                    "<h2><strong><br>What employers want that students don't have:</strong></h3>");

            diff = difference(phrases2, phrases1);
            mapCpy = new HashMap<>(phrases2);
            mapCpy.keySet().retainAll(diff);
            printCloud(
                    index,
                    mapCpy,
                    "<h2><strong><br><br>What students offer but employers don't demand:</strong></h3>");
            outputFooter(index);
            // index.println("<br><br><br><a href=\"jobAndResumeData.html\">Click here for the employers' most frequently-used keywords.</a>");
            // index.println("<br><a href=\"recommendationPage.html\">Click here to see recommendations for employers and students.</a>");

            //outputFooter(student);

            //  recommend = new PrintWriter(new BufferedWriter(new FileWriter(
            //         "data/recommendationPage.html")));
            // outputHeader(recommend);
            // recommend
            //        .println("<br><br><br><a href=\"jobAndResumeData.html\">Click here for the employers' most frequently-used keywords.</a>");
            // recommend
            //       .println("<br><br><br><a href=\"studentPage.html\">Click here for the students' most frequently-used keywords.</a>");
            //outputFooter(recommend);
        } finally {
            if (index != null) {
                index.close();
            }
            if (student != null) {
                student.close();
            }
            if (recommend != null) {
                recommend.close();
            }
        }
    }

    // attempt to open file; throw error if it fail
    public static Map<String, Integer> createFileAndDoStuff(String fileNmae) {
        // attempt to open file; throw error if it fails
        BufferedReader input;
        Map<String, Integer> phrases = new HashMap<String, Integer>();

        try {
            input = new BufferedReader(new FileReader(fileNmae));

            // declare line variable
            String line;

            // start String of file text
            StringBuilder fileText = new StringBuilder();

            // append all lines of text in file into one String
            while ((line = input.readLine()) != null) {
                line = line.toLowerCase();
                fileText.append(line);
                fileText.append(" ");
            }

            // make String version of fileText
            String stringFileText = fileText.toString();

            // split stringFileText by delimiters
            String[] wordTokens = stringFileText.split("[\\s,\"&()-/.!;?]+");

            // initialize phrase count maps
            Map<String, Integer> phrasesOf1 = new HashMap<String, Integer>();

            WordSet wordSet = new WordSet();
            Set<String> commonWords = wordSet.returnSet();

            // iterate through all words in file
            for (String word : wordTokens) {
                if (!commonWords.contains(word) && word.length() >= 2) {
                    addToFrequencyMap(word, phrasesOf1);
                }
            }

            //phrasesOf1.keySet().removeAll(commonWords);

            // get most frequent words
            ArrayList<Map.Entry<String, Integer>> mostCommonWords = new ArrayList<>(
                    phrasesOf1.entrySet());
            Collections.sort(mostCommonWords, new EntryComp());

            for (int i = 0; i < 30; i++) {
                phrases.put(mostCommonWords.get(i).getKey(), mostCommonWords
                        .get(i).getValue());
            }
            input.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return phrases;
    }

    private static Set<String> intersection(Map<String, Integer> map1,
            Map<String, Integer> map2) {
        Set<String> clone1 = new HashSet<>(map1.keySet());
        Set<String> clone2 = new HashSet<>(map2.keySet());

        clone1.retainAll(clone2);
        return clone1;
    }

    private static Set<String> difference(Map<String, Integer> map1,
            Map<String, Integer> map2) {
        Set<String> clone1 = new HashSet<>(map1.keySet());
        Set<String> clone2 = new HashSet<>(map2.keySet());

        clone1.removeAll(clone2);
        return clone1;
    }

    private static void printTable(Map<String, Integer> phrases1,
            Map<String, Integer> phrases2, Set<String> intersection,
            PrintWriter pw) {
        pw.println("<table align=\"center\"; border=\"0\"><br><th><h2><u>Employer data</h2></th></h2> <th><h2><u>Student resume data</u></th></h2>");

        for (String str : intersection) {
            int minCount = CountPhrases2.minCount;
            int maxCount = CountPhrases2.maxCount;

            int count = phrases1.get(str);
            int fontSize = (MAX_FONT_SIZE + MIN_FONT_SIZE) / 2;
            if (minCount != maxCount) {
                fontSize = (((MAX_FONT_SIZE - MIN_FONT_SIZE) * (count - minCount)) / (maxCount - minCount))
                        + MIN_FONT_SIZE;
            }
            pw.println("<tr><td align=\"right\">");
            pw.println("<span style=\"cursor:default\" class=\"f" + fontSize
                    + "\" title=\"count: " + count + "\">" + str
                    + "&#160 &#160 &#160</span>");
            pw.println("</td>");
            count = phrases2.get(str);
            //TODO: Fix this magic numbers.
            minCount = 24;
            maxCount = 79;
            fontSize = (MAX_FONT_SIZE + MIN_FONT_SIZE) / 2;
            if (minCount != maxCount) {
                fontSize = (((MAX_FONT_SIZE - MIN_FONT_SIZE) * (count - minCount)) / (maxCount - minCount))
                        + MIN_FONT_SIZE;
            }
            pw.println("<td align=\"left\">");
            pw.println("<span style=\"cursor:default\" class=\"f" + fontSize
                    + "\" title=\"count: " + count + "\">&#160 &#160 &#160"
                    + str + "</span>");
            pw.println("</td></tr>");
        }
        pw.println("</table>");

    }
}
